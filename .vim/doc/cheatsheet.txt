" vim: filetype=help foldmethod=marker modifiable noreadonly
*cheatsheet.txt* cheatsheet for this specific Vim configuration RubenLaguna

==============================================================================
Editing this file                     *CheatsheetEdit* {{{1

http://vim.wikia.com/wiki/Add_your_note_files_to_Vim_help
http://vim.wikia.com/wiki/VimTip482

How to edit this help file, :set ma , to set it as modifiable |'ma'|

To see the "source code" of this file :set filetype=text |'filetype'|

To open this file you can :help cheatshee.txt, if it doesn't work is because
you need to build the helptags first :helptags ~/.vim/doc see |helptags|

:e $VIMRUNTIME/syntax/help.vim
:help write-local-help " |write-local-help|

How to insert a line full of ===== : in INSERT mode <C-o>78i=<Esc>

Related help topics
* |write-local-help|
* |help-tags|

==============================================================================
Navigate Help *CheatsheetHelp* {{{1

http://vim.wikia.com/wiki/Learn_to_use_help

Follow help links, put cursor in link and press Ctrl-]
Go back , Ctrl-O

Type :help help
Search all the help files with :helpgrep |helpgrep|
	:helpgrep \csearch.\{,12}file
where \c means case insensitive, the pattern looks for "search", then 12
character followe by "file"
To navigate the matches use :cnext |:cnext|, :cprev |:cprev|, :cnfile |:cnfile|,
:cpfile |:cpfile|, :cfirst |:cfirst| and even :cc |:cc|

 * :h :r          Ex command :r
 * :h r           normal mode
 * :h v_r         visual mode
 * :h i_CTRL-Wr   insert mode
 * :h c_CTRL-R    ex command line
 * :h /\r         search pattern
 * :h 'ro'        option
 * :h -r          vim argument

================================================================================
Completion  *CheatsheetCompletion* *CheatsheetAutocompletion* {{{1

See Practical Vim chapter on autocompletion
https://www.safaribooksonline.com/library/view/practical-vim-2nd/9781680501629/f_0157.xhtml#chp.auto.completion

The Supertab, YouCompleteMe, VimCompleteMe, neocomplete, etc are for complete
as you type, without having to trigger the completion with a keystroke. If you
don't  mind to type |i_CTRL-N| or |i_CTRL-X_CTRL-N|

Autocompletion is triggered from |Insert-Mode with either |i_CTRL-N| or |i_CTRL-P|
both trigger generic keyword autocompletion.


Types of completion
* CTRL-N    Generic keywords |compl-generic|
* CTRL-X CTRL-N Current buffer keywords |compl-current| |i_CTRL-X_CTRL-N|
* CTRL-X CTRL-I Included file keywords |compl-keyword|
* CTRL-X CTRL-] tags file keywords |compl-tag|
* CTRL-X CTRL-K Dictionary lookup  |compl-dictionary|
* CTRL-X CTRL-L whole line completion |compl-whole-line|
* CTRL-X CTRL-F Filename completion |compl-filename|
* CTRL-X CTRL-O Omnicompletion |compl-omni|

Once the completion is invoked a popup will appear you can navigate with
CTRL-N and CTRL-P (which will modify the buffer) or with <Down> and <Up>
(which will select entries in the popup without modifying the document).

You need to CTRL-E will terminate the completion, dimisses the popup and
restores the text to the partial text that was typed before autocompletion was
invoked.

To invoke the autocompletion just to see the proposals and refine by typing
use CTRL-N CTRL-P the CTRL-N selects the first completion and CTRL-P bring
back to the partial text so you can continue typing there. This works for the
other types of completions as well CTRL-X CTRL-N CTRL-P for example.

The Generic keyword autocompletion |compl-generic| merges several sources ,
which sources are used is controlled by the option |'complete'|
>     :set complete=.,w,b,u,t,k~/.vim/keywords.txt
>
When we use autocomplete to expand a word if we invoke autocomplete a second
time it will insert the word that followed the original completion, that
allows to autocomplete not just words but parts of sentences incrrementally.

The file autocompletion |compl-filename| exapnds paths relative to the
_current directory_ not relative to the file currently being edited. Use
|:pwd| to see what is the curren directory and |:cd|  and |:cd-| to change
directories before doing the CTRL-X CTRL-L. In the future maybe the |'path'|
option will be used.

Omni-completion is triggred by CTRL-X CTRL-O (see |compl-omni|) the
functionality is filetype dependent see |compl-omni-filetypes| (see the
specific help for each filetype |ft-c-omni|, |ft-php-omni|,
|ft-php-omni|, etc). You can figure out how to write your own omni-completion
plugins by reading the |complete-functions| (|omnifunc| and |completefunc|)
>
as an example of how a new complete is implemented look at the |vim-go|
see Ëœ/.vim/autoload/go/complete.vim which implements the function
> function! go#complete#Complete(findstart, base) abort
which follows the conventions of |complete-functions|.
It really uses s:gocodeAutocomplete() to generate the completions that it
stores in g:gocomplete_completions.
g:gocodeAutocomplete calls gocode autocomplete --in=tempfilename -f=vim fullpath_to_buffer.go offset
expand('%:p')
It uses |tempname()| to generate a temporary filename
the offset is calculated using |line()| and |col()|, but to account for utf-8
encoding it does


Related vim help:
 * |'infercase'|
 * |ins-completion|
 * |popupmenu-completion|
 * |compl-current|
 * |compl-keyword|
 * |include|
 * |compl-tag|
 * |compl-dictionary|
 * |dictionary|
 * |compl-whole-line|
 * |compl-filename|
 * |:cd| and |:cd-|
 * |compl-omni|
 * |complete-functions| (|omnifunc| and |completefunc|)
 * |CompleteDone| autocommand event

==============================================================================
Folding *CheatsheetFolding* *CheatsheetFold* {{{1

|zi| disable all folding
|za| toggle fold (open/close fole). <Space> is mapped to za
zA toggle all folds (open all thaw were closed and close the open ones)
|zc| close a fold
zo open a fold
|zM| close all folds
|zR| will open all folds
zO will open all fold inside the current fold recursively
zC will close folds recusively
|zv| open the fold necesarry to reveal the cursor
zm close one foldlevel
zr open a foldlevel
zj navigate to next fold
zk navigate to previous fold
zMzv close all fold except the current one
zMzvzz Refocus, like previous but center view

Writing a custom folding expression / function
http://vimcasts.org/episodes/writing-a-custom-fold-expression/
> set foldcolumn=3 "numer of characters in the gutter to show fold bars"
> set foldmethod=marker "you need to add \{\{{1 \{\{{2 etc to the file
> set foldmethod=indent "fold based on indentation"
> set foldmethod=expr  "fold based on |'foldexpr'|, set 'foldexpr' to a func
>                      " that returns ">1", "=", ">3", etc|

Manual folds
You need to set |foldmethod| to manual
> set fdm=manual
then do a visual selection like Vjjj<Esc>  the you can use |zf| to create a
fold (using the current visual selection) that you can open via |zo| and close
with |zc|
THe folds will be lost when the buffer is closed but you can save them with
|:mkview| and recovered with |:loadview|


Related help
* |folding|
* |'foldlevel'|
* |'foldmethod'|
* |'foldcolumn'|


==============================================================================
Troubleshooting Vim *CheatsheetTroubleshooting* {{{1

|:messages|  show error messages from vim from previous commands
|:set| buftype
|:echo| &buftype

To see from which file an options was set use |:set-verbose| see also
|:verbose|
:verbose set shiftwidth cindent?

==============================================================================
Plugins *CheatsheetPlugings* {{{1


* unite.vim
* Tabular
* EasyAlign
* |vim-go|


vim-go plugin for Golang development *CheatsheetGo* {{{2

See vim-go-tutorial at
https://github.com/fatih/vim-go-tutorial/blob/master/README.md


First do |:GoInstallBinaries| or |:GoUpdateBinaries| so that guru, gofmt,
gorename, godef, goimports, etc are installedi.

|:GoRun| to run small scripts
|:GoBuild| this compiles the filed instead of running it. No binaries pollute
the dir, it cds into the source pkg , parses errors into quickfix, uses
|dispatch| plugin or vim 8 async api in the future

The |:GoBuild| works better with |autowrite|
> set autowrite


Many commands like |:GoBuild|, |:GoRun|, |:GoInstall|, |:GoTest| use the
|quickfix| window, so it makes sense to add some mappings for quick |:cnext|
and |:cprevious|
> map <C-n> :cnext<CR>
> map <C-m> :cprevious<CR>
> nnoremap <leader>a :cclose<CR>

To load specific settings for Go files you can use
> autocmd FileType go nmap <leader>b <Plug>(go-build)
> autocmd FileType go nmap <leader>r <Plug>(go-run)
> autocmd FileType go nmap <leader>t <Plug>(go-test)
but I put everything in ~/.vim/ftplugin/go/go.vim


The vim-go uses both |location-list| (one for Build errors, another for Tests,
etc)  and |quickfix|. But we can make vim-go to only use quickfix with
> let g:go_list_type = "quickfix"


|:GoTest| runs synchronously but there is timeout of 10s 
> let g:go_test_timeout = '10s'


|:GoTestFunc| only tests the function that is under the cursor. The errors
will open in a |quickfix|  window.

|:GoTestCompile| builds the test file without running it, in case it takes
long to run and you only want to how if your changes compiles.

vim-go provides autocompletion direclty via CTRL-X CTRL-O (if you want as you
type completion without having to trigger it with a chord you need
YouCompleteMe, Supertab, neocomplete, etc.)

|:GoCoverage| and |:GoCoverageClear| and |:GoCoverageClear| and
|:GoCoverageBrowser| . The test must pass to get coverage
The <leader>c will run |:GoCoverageToggle|

The command |:GoImport|  allows to add a import line at the top of the file
without having to jump there
> :GoImport strings
> :GoImportAs str strings
To remove an import statement use |:GoDrop|
> :GoDrop string
>
But we have the goimports tool, we can instruct vim-go to run goimports to
"format" the code (instead of using "gofmt")
> let g:go_fmt_command = "goimports"

Running goimports on save may be slow so you can revert
> let g:go_fmt_command = "gofmt"
and run goimports on demands with |:GoImports| (note the extra s)

vim-go provides the |text-objects| af and if, so you can do vaf , vif , daf,
dif, yif, yaf, etc. This text objects include the comments (documentation) if
you don't like that you can use the setting:
> let g:go_textobj_include_function_doc = 0

See more about the text-objects at https://medium.com/@farslan/treating-go-types-as-objects-in-vim-ed6b3fad9287#.45q2rtqgf

the |gS| and |gJ| from the splitjoin.vim can be used to split expression
althought is not really a go-aware plugin.

There are some go related *UltiSnips* snippets
https://github.com/fatih/vim-go/blob/master/gosnippets/UltiSnips/go.snippets

* fn -> fmt.Println
* ff -> fmt.Printf()
* ln -> log.Println()
* lf -> log.Printf()
* errp -> if err != nil

==============================================================================
Unite.vim keyboard shortcuts *CheatsheetUnite* {{{1

The |unite.vim| are buffer so you can CTRL-^ to go back where you came from

<Leader> is \

In normal mode:
CTRL-P open the file browser
<Leader>mru to open a list of the Most Recently Used filed
<Leader>o   Outline
<Leader>t   Tags
<Leader>y   Yank. We don't have it configured properly I guess we need another
            plugin called https://github.com/Shougo/neoyank.vim
<Leader>e   Open buffers, you have to wait for the timeout (see |timeout|,
            |ttimeout|, |ttimeoutlen|) because it needs to distinguish
            between <Leader>e and <Leader>ev (open vimrc file)
<Leader>g   Grep
<Leader>l   Resume |:UniteResume|


Related Help:
* How to add new sources |unite-create-source|
==============================================================================
Miscellaneous *CheatsheetMisc* {{{1

Create a new command with
>  :command :helptags ~/.vim/doc | :help Cheatsheet

The above creates a new command :Cheatsheet that will run :helptags and then
:help

|expand()| allows to get
* expand('%:p')  full path of current buffer



Vim script / VimScript variable scopes: http://learnvimscriptthehardway.stevelosh.com/chapters/20.html
* scopes are explained in |internal-variables|
* |a:var|  is the |function-argument| scope
* |g:var| is the  |global-variable| scope  |g:var| |g:|
*

|mapleader|  the default leader is \ , but it's more convenient to change it
to the "," although that will prevent from searching backwards
> let mapleader = ','
>


