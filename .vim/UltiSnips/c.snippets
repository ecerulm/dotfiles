snippet inc "#include local header (inc)"
#include "${1:`!p snip.rv = snip.basename + '.h'`}"
endsnippet

snippet "inc(uint|int)" "#include <stdint.h>" r
#include <stdint.h> /* uint32_t, uint16_t, etc. */
$0
endsnippet

snippet	"inc(hton|ntoh)" "#include " r
#include <arpa/inet.h> /* htonl(), ntohl(), etc */
$0
endsnippet

snippet main "main() (main)"
int main(int argc, char *argv[])
{
	${VISUAL}${0}
	return 0;
}
endsnippet

snippet wh "while loop"
while(${1:/* condition */}) {
	${VISUAL}${0}
}
endsnippet

snippet shmopen "shmopen/mmap"
int r;

const char *memname = "sample";
const size_t region_size = sysconf(_SC_PAGE_SIZE);

printf("region_size = %zu\n", region_size);
int fd = shm_open(memname, O_CREAT | O_TRUNC | O_RDWR, 0666);
if(fd == -1)
  error_and_die("shm_open");

r = ftruncate(fd, region_size);
if(r != 0)
  error_and_die("ftruncate");

void *ptr = mmap(0, region_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
if(ptr == MAP_FAILED)
  error_and_die("mmap");
close(fd);

pid_t pid = fork();

if (pid == 0) {
  u_long *d = (u_long *) ptr;
  *d = 0xdbeebee;
  exit(0);
}
else {
  int status;
  waitpid(pid, &status, 0);
  printf("child wrote %#lx\n", *(u_long *)ptr);
}

r = munmap(ptr, region_size);
if (r != 0)
  error_and_die("munmap");

r = shm_unlink(memname);
if(r != 0)
  error_and_die("shm_unlink");
endsnippet

snippet pthreadcreate "Create a new pthread"
pthread_t ${1:p};
/*  void child_main_func(void *arg) { return NULL;} */
pthread_create(&$1,/* attrs */ NULL, ${2:child_main_func}, /* void * arg */ NULL);
/* pthread_join($1,NULL); */
endsnippet


# http://en.wikipedia.org/wiki/Include_guard
snippet incguard "#ifndef NAME_H Include Guards" b
#ifndef ${1:FILENAME}_H
#define $1_H
${0}
#endif /* $1_H */
endsnippet

snippet typedef "typedef struct {} name" b
typedef struct {
	$0
} ${1:name};
endsnippet

snippet struct "struct name {}" b
struct ${1:name} {
	$0;
};
endsnippet

snippet enum "enum name {};" b
enum ${1:enumname} { ${2:VAL1}, ${3:VAL2}};
$0
endsnippet

snippet for "for loop"
for (int ${1:i}=0;$1<${2:INTMAX};$1++) {
	${VISUAL:code}
}
$0
endsnippet

snippet notimpl "Not Implemented error" b
printf("Not Implemented\n");
exit(EXIT_FAILURE);
endsnippet

snippet printf "printf with newline" b
printf("$1\n",$2);
$0
endsnippet

snippet	memset "memset (dest, value, size)"
memset(${1:void *s}, ${2:int c}, ${3:size_t len});
$0
endsnippet

snippet config.h "include <config.h>"
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif
endsnippet

# snippet incsocket "includes for sockets"
# #include <errno.h>
# #include <string.h> /* memset, etc */
# #include <unistd.h> /* read(), write() */
# #include <netdb.h>  /* _in_addr_t require by <netint/in.h> */
# #include <sys/socket.h> /* recv, send, sendmsg, recvmsg */
# #include <netinet/in.h> /* sockaddr_in_t */
# #include <sys/uio.h> /* struct iovec */
# #include <stdlib.h> /* exit() */
# #include <limits.h> /* constants */
# #include <stdio.h> /* printf(), perror() */
# $0
# endsnippet

snippet incall "add the usual includes"
#include <errno.h>
#include <string.h> /* memset, etc */
#include <unistd.h> /* read(), write() */
#include <stdlib.h> /* exit() */
#include <limits.h> /* constants */
#include <stdio.h> /* printf(), perror() */
#include <stddef.h> /* int*_t */
#include <stdbool.h> /* bool types true, false */
#include <inttypes.h> /*  printf(" %" PRIu32 "\n"), my_uint32_t) */
#include <string.h>	/* size_t, memcopy(), memset()*/
#include <sched.h> /* cpu_set_t, sched_yield, sched_setaffinitiy */
$0
endsnippet

snippet udpsocketsetup "get and addrinfo (dns resolve)"
const char* hostname = 0; /* localhost */
const char *portname = "daytime"; /* if AI_NUMERICSERV this string can conntain a number */
struct addrinfo hints;
memset(&hints,0,sizeof(hints));
hints.ai_family=AF_UNSPEC;
hints.ai_socktype=SOCK_DGRAM;
hints.ai_protocol=0;
hints.ai_flags=AI_ADDRCONFIG; /* AI_NUMERICSERV */
struct addrinfo* res=0;
int err=getaddrinfo(hostname,portname,&hints,&res);

if (err!=0) {
	perror("getaddrinfo: failed to resolve remote socket address");
	exit(EXIT_FAILURE);
}
endsnippet

snippet rcexit "check rc and exit"
if (${1:rc}<0) {
	perror("${2:functioname}");
	exit(EXIT_FAILURE); /* stdlib.h */
}
$0
endsnippet

snippet elapsedtime "measure elapsed time with ms accuracy"
/* #include <time.h> */
clock_t start = clock();
/* code to measure */
clock_t stop = clock();
double runtime_diff_ms = (stop-start) * 1000. / CLOCKS_PER_SEC;
printf("Took %f ms\n", runtime_diff_ms);
$0
endsnippet

snippet todo "/* TODO: todo message */"
/* TODO: $1 */
$0
endsnippet

snippet glibtest "Glib testcase"
void ${1:testcasename}(dfixture *df, gconstpointer testdata) {
	$0
	g_test_skip("Not implemented yet");
}

endsnippet

snippet exit "exit(EXIT_FAILURE)"
exit(EXIT_FAILURE);
endsnippet

snippet perror "perror"
if (${1:rc} == -1) {
	perror("${2:functionthatfailed}");
	exit(EXIT_FAILURE);
}$0
endsnippet

snippet if "surround with if"
if (${1:condition}) {
	${VISUAL}
}
endsnippet

snippet incperror "#include <stdio.h>"
#include <stdio.h> /* perror(), printf() */
endsnippet

snippet "incf?printf" "#include <stdio.h>" r
#include <stdio.h> /* perror(), printf(), fprintf() */
endsnippet


snippet "inc(exit|free|malloc)" "#include <stdlib.h>" r
#include <stdlib.h> /* exit(), malloc(), free() */
$0
endsnippet

snippet "incmem(set|cpy)" "#include <string.h>" r
#include <string.h> /* memset(), memcpy() */
endsnippet

snippet incfcntl "#include for fnctl" b
#include <unistd.h>
#include <fcntl.h>
endsnippet

snippet incassert "#include for assert" b
#include <assert.h> /* assert() */
endsnippet

snippet incshm "#include for POSIX shared memory"
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
endsnippet

snippet "inc(true|false|bool)" "#include <stdbool.h>" r
#include <stdbool.h> /* true, false */
endsnippet

snippet "inc(null|sizet)" "#include <stddef.h>" r
#include <stddef.h> /* size_t, NULL */
endsnippet

snippet "inc(socket|accept|listen|send)" "#include <sys/socket.h>" r
#include <sys/types.h>
#include <sys/socket.h> /* socket(), bind(), listen(), accept() */
$0
endsnippet

snippet "inc(getaddrinfo|freeaddrinfo|gai_strerror)" "#include <netdb.h>" r
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h> /* getaddrinfo(), freeaddrinfo(), gai_strerror() */
$0
endsnippet

snippet socket "int fd = socket(...)"
int ${1:fd} = socket(AF_INET, SOCK_${2:DGRAM}, 0); /* <sys/socket.h> <sys/types.h> */
endsnippet


snippet bind "bind(fd,...)"
struct sockaddr_in addr;
memset(&addr, 0, sizeof(struct sockaddr_in)); /* <string.h> */
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = INADDR_ANY;
addr.sin_port = htons(${1:2222});
bind(${2:fd}, (struct sockaddr *) &${2:addr}, sizeof(struct sockaddr_in));
endsnippet

snippet recvfrom "recvfrom(..., sourceaddr)"
/* socklen_t len; */
/* struct sockaddr_in claddr; */
/* ssize_t numBytes; */
numBytes = recvfrom(${1:fd}, ${2:buf}, ${3:BUF_SIZE}, 0, (struct sockaddr *) &${4:claddr}, &${5:len});
endsnippet

snippet getopt
int opt;
struct args args;

while ((opt = getopt(argc,argv,":a:c:")) != -1) {
	printf("opt =%3d (%c); optind =%d", opt, printable(opt), optind);
	if (opt == '?' || opt == ':')
		printf("; optopt =%3d (%c)", optopt, printable(optopt));
	printf("\n");

	switch (opt) {
		case 'a': args.stringmember = optarg ;break;
		case 'c': args.numbermember = strtol(optarg, NULL, 0);break;
		case ':': printf("Missing argument\n"); exit(EXIT_FAILURE); break;
		case '?': printf("Unrecognized option\n"); exit(EXIT_FAILURE); break;
		default:
			printf("Unexpected case\n");
      exit(EXIT_FAILURE);
	}
}
endsnippet

snippet ao "Surround with ACCESS_ONCE"
ACCESS_ONCE(${VISUAL})$0
endsnippet

snippet sighandler "Signal handler <signal.h>"
struct sigaction ${1:sa};
sigemptyset(&$1.sa_mask);
$1.sa_flags = 0;
$1.sa_handler = ${2:handler};
if (sigaction(SIGINT, &$1, NULL) == -1) {
	perror("sigaction");
	exit(EXIT_FAILURE);
}
if (sigaction(SIGTERM, &$1, NULL) == -1) {
	perror("sigaction");
	exit(EXIT_FAILURE);
}
endsnippet

snippet eq " == "
==
endsnippet

snippet as " = "
=
endsnippet

snippet mua "mu_assert()" b
mu_assert("${2:message}", ${1:condition});
endsnippet


snippet terminate "terminate()" b
#ifdef __GNUC__
__attribute__ ((__noreturn__)) /* prevent warning if this function is called as last statement in a non-void function */
#endif
static void terminate(Boolean useExit3)
{
	char *s;

	/*  Dump core if EF_DUMPCORE environment variable is defined. */
	/*  Otherwise call exit(3) or _exit(2) dependig on the value of */
	/*  useExit3 */

	s = getenv("EF_DUMPCORE");
	if (s != NULL && *s != '\0')
		abort(); /* generate a coredump */
	else if (useExit3)
	  exit(EXIT_FAILURE); /* flushing */
	else
	  _exit(EXIT_FAILURE); /* no flushing */
}
endsnippet

snippet errExit "errExit" b

void
errExit(const char *format, ...)
{
	va_list argList;

	va_start(argList, format);
	outputError(TRUE, errno, format, argList)
	va_end(argList);

	terminate(TRUE);
}
endsnippet
