snippet main "hello world program" !b
package main

import (
	"fmt"
)

func main() {
	fmt.Println("Hello world")
}
endsnippet

snippet for "for i:= 0" !b
for i := 0; i < ${1:100}; i++ {
	$0
}
endsnippet

snippet waitgroup "var wg sync.WaitGroup" !b
var wg sync.WaitGroup
endsnippet

snippet pipeline "make a pipeline function" !b
func pipelinefunc(nums ... int) <-chan int {
	out := make(chan int)
	go func() {
	  defer close(out)
		for i, n := range nums {
			out <- n
		}
	}
	return out
}

endsnippet

snippet ctxtimeout "context.WithTimeout" !b
timeout, err := time.ParseDuration("10s")
ctx, err := context.WithTimeout(context.Background(), timeout) // access ctx.Done()
endsnippet

snippet goroutinefunc "make a func that returns a channel" !b
func ${1:funcname}() <-chan ${2:int} {
	out := make(chan $2)
	go func() {
		defer close(out)
		for {
			select {
			case $0:
			}
		}
	}()
	return out
}
endsnippet


snippet forchan "for n := range ch {}" !b
for ${1:elem} := range ${2:ch} {
	$0
}
endsnippet

snippet forarray "for i, elem := range" !b
for _, ${1:elem} := range ${2:myArray} {
	$0
}
endsnippet

snippet formap "for k,v := range myMap" !b
for k, v := range ${2:myMap"} {
	$0
}
endsnippet

snippet println "fmt.Println()"
fmt.Println($0)
endsnippet

snippet ticker "time.NewTicker" !b
ticker := time.NewTicker(5 * time.Second)
endsnippet

snippet sleeprandom "time.Sleep(rand.Intn(5) * time.Second)" !b
time.Sleep(time.Duration(rand.Intn(5) + 1) * time.Second)
endsnippet

snippet first "repeat query to multiple, get first response" !b
func First(queryString string, servers ...string) string {
	out := make(chan string)
	for _,server := range servers {
		go func(server string){ out <- search(queryString, server) }(server)
	}
	return <-out
}
endsnippet

snippet forselect "for { select {} }" !b
for {
	select {
	case $0:
	}
}
endsnippet

snippet infiniteloop "for {}" !b
for {}
endsnippet

snippet gofunc "go func() {for{select{}}}" !b
go func() {
	for {
		select {
		case $0:
		}
	}
}()
endsnippet

snippet broadcast "copy from one channel to several" !b
go func() {
	for {
		msg := <-ch // input
		for _, out := range cs {
			out <- msg // this blocks you could run this in yet another goroutine
		}
	}
}()
endsnippet

snippet parsejson "json.Unmarshal(data, &dest)" !b
ok := json.Unmarshall(${1:data}, ${2:dest})
if !ok {
	${3:panic(fmt.Errorf("Unparseable"))}
}
endsnippet

snippet printf "fmt.Printf()" !b
fmt.Printf("%s\n", data)
endsnippet

snippet handler "func xxxx(w http.ResponseWriter, req *http.Request)" !b
func ${1:handler}(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	w.Write([]byte("This is an example server"))
	$0
}
endsnippet

snippet signal "os.Notify(ch, os.Interrupt)" !b
// import "os" "os/signal"
quit := make(chan os.Signal)
signal.Notify(quit, os.Interrupt)
endsnippet

snippet httpclient "var httpClient = &http.Client{...}" !b
// import "net/http"
var httpClient  = &http.Client{
	Timeout: time.Second * 3,
	Transport: &http.Transport{
		TLSClientConfig: &tls.Config{
			Rand: zeroSource{}, //TODO: Only for reproducible output during development
			InsecureSkipVerify: true, //TODO: Only for development, don't use in production
		},
	},
}
endsnippet

snippet pipe "r,w := io.Pipe()" !b
//import "io" "io/ioutil"
r, w := io.Pipe()

go func() {
defer w.Close()
// code that writes to w w.Write(...)
}()

buf, err := ioutil.ReadAll(r) // code that reads from r (here or in goroutine)

endsnippet


snippet httperrorresponse "http.Error(w, messge, httpstatuscode" !b
http.Error(w, "${0:error message sent on the body of response}", ${1:http.StatusBadRequest})
endsnippet

snippet reader2buf "b, err := ioutil.ReadAll(r)" !b
var b, err = ioutil.ReadAll(r) // import "io/ioutil"
if err != nil {
	//log.Fatal(err)
}
endsnippet

snippet xml "`xml:...`"
\`xml:"$0"\`
endsnippet
