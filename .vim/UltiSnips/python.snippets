
snippet basedir "basedir = os.path.abspath(...)" b
basedir = os.path.abspath(os.path.dirname(__file__))
endsnippet

snippet patchers "insert patchers" b 
with self.patchers_ok['os.listdir'], self.patchers_ok['os.environ'], self.patchers_ok['os.path']$0:
endsnippet

snippet property "create a property" b
@property
def ${1:property_name}(self):
	$0
	return self._$1
endsnippet

snippet len "wrap with len()"
len(${VISUAL})
endsnippet

#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
# encoding: utf-8
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == '__main__':
	${1:main()}$0
endsnippet

snippet for "for loop" b
for ${1:item} in ${2:iterable}:
	${3:pass}
endsnippet

snippet class "add a class" b
class ${1:MyClass}(${2:object}):

	def __init__(self$4):
		${5:pass}
endsnippet

snippet super "call superclass implementation" b
super(${1:CurrentClass}, self).${2:__init__}(${0})
endsnippet

snippet init "def __init__(self):"
def __init__(self$1):
	pass
endsnippet

####################
# If / Else / Elif #
####################
snippet if "If" b
if ${1:condition}:
	${2:pass}
endsnippet

snippet ife "If / Else" b
if ${1:condition}:
	${2:pass}
else:
	${3:pass}
endsnippet

snippet ifee "If / Elif / Else" b
if ${1:condition}:
	${2:pass}
elif ${3:condition}:
	${4:pass}
else:
	${5:pass}
endsnippet

###############
# Def	/ imports
###############

snippet def "function with docstrings" b
def ${1:function}(self$2):
	${0:pass}
endsnippet

# doesn't expand when there is a word in front
snippet /(^|(?<=\W))\./ "self." r
self.
endsnippet

snippet from "from module import name" b
from ${1:module} import ${2:Stuff}
endsnippet

##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
endsnippet

snippet try "Try / Except / Else" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet try "Try / Except / Finally" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet


#####################
# Assertions & Tests #
#####################


snippet test "Add skipped test" b
def $0test_xxx_should_do_xx_when_xxx(self):
	# Setup
	# Exercise SUT
	# Verify SUT state / behaviour
	# Teardown
	self.fail("Not implemented yet")

endsnippet

snippet pdb "Set PDB breakpoint" b
import pdb; pdb.set_trace()
endsnippet

snippet ipdb "Set IPDB breakpoint" b
import ipdb; ipdb.set_trace()
endsnippet

snippet pudb "Set PUDB breakpoint" b
import pudb; pudb.set_trace()
endsnippet

snippet ae "Assert equal" b
self.assertEqual(${1:first},${2:second})
endsnippet

snippet at "Assert True" b
self.assertTrue(${0:False})
endsnippet

snippet af "Assert False" b
self.assertFalse(${1:expression})
endsnippet

snippet aae "Assert almost equal" b
self.assertAlmostEqual(${1:first},${2:second})
endsnippet

snippet ar "Assert raises" b
self.assertRaises(${1:exception}, ${2:func}${3/.+/, /}${3:arguments})
endsnippet

snippet an "Assert is None" b
self.assertIsNone(${0:expression})
endsnippet

snippet ann "Assert is not None" b
self.assertIsNotNone(${0:expression})
endsnippet

snippet testcase "pyunit testcase" b
class Test${1:Class}(${2:unittest.TestCase}):

	def setUp(self):
		${4:pass}

	def tearDown(self):
		${5:pass}

	def test_${6:name}(self):
		${7:pass}
endsnippet

snippet	alltests "alltests.py suite" b
#!/usr/bin/env python
# encoding: utf-8


import unittest
import sys
sys.path.append('unittests')


modules_to_test = (
    'fooTest',
    'barTest',
    'bazTest',
)


def suite():
    alltests = unittest.TestSuite()
    for module in map(__import__, modules_to_test):
        alltests.addTests((unittest.findTestCases(module)))
    return alltests

if __name__ == '__main__':
    unittest.main(defaultTest='suite')
endsnippet

snippet cartesian "numpy cartesian function definition" s

import numpy as np

def cartesian(arrays, out=None):
    """
    Generate a cartesian product of input arrays.

    Parameters
    ----------
    arrays : list of array-like
        1-D arrays to form the cartesian product of.
    out : ndarray
        Array to place the cartesian product in.

    Returns
    -------
    out : ndarray
        2-D array of shape (M, len(arrays)) containing cartesian products
        formed of input arrays.

    Examples
    --------
    >>> cartesian(([1, 2, 3], [4, 5], [6, 7]))
    array([[1, 4, 6],
           [1, 4, 7],
           [1, 5, 6],
           [1, 5, 7],
           [2, 4, 6],
           [2, 4, 7],
           [2, 5, 6],
           [2, 5, 7],
           [3, 4, 6],
           [3, 4, 7],
           [3, 5, 6],
           [3, 5, 7]])

    """

    arrays = [np.asarray(x) for x in arrays]
    dtype = arrays[0].dtype

    n = np.prod([x.size for x in arrays])
    if out is None:
        out = np.zeros([n, len(arrays)], dtype=dtype)

    m = n / arrays[0].size
    out[:,0] = np.repeat(arrays[0], m)
    if arrays[1:]:
        cartesian(arrays[1:], out=out[0:m,1:])
        for j in xrange(1, arrays[0].size):
            out[j*m:(j+1)*m,1:] = out[0:m,1:]
    return out
endsnippet


snippet printerr "print('', file=sys.stderr)"
print('$1', file=sys.stderr)
endsnippet

snippet hexstring "string to hex bytes" w
":".join("{:02x}".format(ord(c)) for c in ${1:result})
endsnippet

snippet writefile "with open ... write"
with open(${1:filename}, "w") as ${2:f}:
	f.write($3)
endsnippet

snippet openfile "with open ... read"
with open(${1:filename}, "r") as ${2:f}:
	f.read()
endsnippet


snippet argparse "argparse verbose levels"
import argparse
import logging

log_levels_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL,
        }

parser = argparse.ArgumentParser(description="A test program")
parser.add_argument('-v', '--verbose', action='count' )
parser.add_argument('--log-level', choices=log_levels_map)
args = parser.parse_args()

print args
level = logging.WARNING
if args.log_level:
    level = log_levels_map[args.log_level]
if args.verbose:
    levels = [logging.WARNING, logging.INFO, logging.DEBUG]
    level = levels[min(len(levels)-1,args.verbose)] # capped to the number of levels

logging.basicConfig(level=level,
                    format="%(asctime)s %(levelname)s %(message)s")

logging.debug("a debug message")
logging.info("a info message")
logging.warning("a warning message")
logging.error("a error message")
logging.critical("a critical message")
endsnippet



snippet tk "Tkinter windows and mainloop"
root = tk.Tk()
mylabel = tk.Label(root, text="I am a label widget")
mylabel.pack()
root.mainloop()
endsnippet

snippet tktoplevel "Tkinter Toplevel"
top = tk.Toplevel()  # Top level window at the same level as root
top.title("About this application")

msg = tk.Message(top, text="my about message")
msg.pack()
button = tk.Button(top, text="Dismissin", command=top.destroy)
button.pack()
endsnippet

snippet tkcheckbutton "Tkinter checkbutton"
var = tk.IntVar()
c = tk.Checkbutton(root, text="Expand", variable=var, command=afunction) # def afunction(self, event): print var.get()
c.pack()
endsnippet

snippet tklabelframe "Tkinter LabelFrame"
group = tk.LabelFrame(root, text="Group", padx=5, pady=5)
group.pack(padx=10,pady=10)
endsnippet

snippet tklistbox "Tkinter listbox"
listbox = tk.Listbox(root)
listbox.pack()
listbox.insert(tk.END, "a list entry")
for item in ["one", "two", "three"]:
	listbox.insert(tk.END, item)
endsnippet

snippet tkscrollbar "Tkinter scrollbar"
frame = tk.Frame(root)
scrollbar = tk.Scrollbar(frame, orient=tk.VERTICAL)
listbox = tk.Listbox(frame, yscrollcommand=scrollbar.set)
scrollbar.config(command=listbox.yview)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

listbox.insert(tk.END, "a list entry")
for item in range(100):
	listbox.insert(tk.END, "item%d" % item)

listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=1)
frame.pack()
endsnippet

snippet tkmenu "Tkinter add a menubar"
menubar = tk.Menu(root)

# create a pulldown menu, and add it to the menu bar
filemenu = tk.Menu(menubar, tearoff=0)
filemenu.add_command(label="Open", command=hello)
filemenu.add_command(label="Save", command=hello)
filemenu.add_separator()
filemenu.add_command(label="Exit", command=root.quit)
menubar.add_cascade(label="File", menu=filemenu)

# create more pulldown menus
editmenu = tk.Menu(menubar, tearoff=0)
editmenu.add_command(label="Cut", command=hello)
editmenu.add_command(label="Copy", command=hello)
editmenu.add_command(label="Paste", command=hello)
menubar.add_cascade(label="Edit", menu=editmenu)

helpmenu = tk.Menu(menubar, tearoff=0)
helpmenu.add_command(label="About", command=hello)
menubar.add_cascade(label="Help", menu=helpmenu)

root.config(menu=menubar)
endsnippet

snippet "tk(combobox|optionmenu)" "Tkinter combobox" r
OPTIONS= ["egg", "bunny", "chicken"]
variable = tk.StringVar(root)
variable.set(OPTIONS[0])  # default value

w = apply(tk.OptionMenu, (root, variable) + tuple(OPTIONS))
# w = tk.OptionMenu(root, variable, "egg", "bunny", "chicken")
w.pack()
endsnippet

snippet "tk(slider|scale)" "Tkinter slider/scale" r
w = tk.Scale(root, from_=0, to=100, orient=tk.HORIZONTAL)
w.pack()

def callback():
	print w.get()

b = tk.Button(root, text="Get", command=callback)
b.pack()
endsnippet

snippet flask "Flask app" b

from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return "Hello world!"

if __name__ == '__main__':
    app.run()
endsnippet

snippet tkgui

import Tkinter as tk
class App(object):
	def __init__(self, root):
		frame = tk.Frame(root)
		frame.pack()  #  no options takes full container

		self.button1 = tk.Button(root, text="Button1", command=root.quit)
		self.button1.pack(side=tk.LEFT)
		self.button2 = tk.Button(root, text="Button2", command=root.quit)
		self.button2.pack(side=tk.LEFT)
		self.button3 = tk.Button(root, text="Button3", command=root.quit)
		self.button3.pack(side=tk.LEFT)

root = tk.Tk()

app = App(root)

root.mainloop()
#root.destroy()  # optional 
endsnippet


snippet basedir
os.path.abspath(os.path.dirname(__file__))
endsnippet


snippet argparse "argparse common"
parser = argparse.ArgumentParser(description='What the program does')
parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin)
parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'), default=sys.stdout)
parser.add_argument('-v', '--verbose',
                    help="Be verbose", dest='loglevel', action='store_const',
                    const=logging.INFO)
parser.add_argument('-d', '--debug',
                    help="Prints lots of debugging statements",
                    dest='loglevel', action='store_const', const=logging.DEBUG,
                    default=logging.WARNING)
args = parser.parse_args()
logging.basicConfig(level=args.loglevel)
endsnippet

snippet "(envget|getenv)" "os.environ.get" rw
os.environ.get('${1:ENVVAR}') or 'default'$0
endsnippet

snippet socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
endsnippet

snippet tcpserver
import socket
import time
import threading

HOST = "0.0.0.0"
PORT = 5006

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind((HOST, PORT))
s.listen(100)

def sendloop(conn):
	print("Started thread",threading.current_thread().name)
		while True:
			conn.send("Hola\n")
			time.sleep(1)

while True:
		conn, addr = s.accept()  # will block until we get a connection
		myThread = threading.Thread(target=sendloop, args=(conn,))
		myThread.daemon = True
		myThread.start()
endsnippet


snippet thread
threading.Thread(target=${1:myfunc}, args=(,))
endsnippet

snippet protocol
class ${1:MyProtocol}:
	def __init__(self, message, loop):
		self.message = message
		self.loop = loop
		self.transport = None


	def connection_made(self, transport):
		self.transport = transport
		print("Send:", self.message)
		self.transport.sendto(self.message.encode())

	def error_received(self, exc):
		print('Error received', exc)


	def connection_lost(self, exc):
		print("Socket closed, stop the event loop")
		self.loop.stop()

connect = loop.create_datagram_endpoint(lambda: $1(message, loop), remote_addr=('127.0.0.1', 2222))
transport, protocol = loop.run_until_complete(connect)
endsnippet

snippet fileconfig
import logging
from logging.config import fileConfig

logger = logging.getLogger()
fileConfig('logging_config.ini', disable_existing_loggers=False)
endsnippet

snippet futureimports "from __future__ import ..." b
from __future__ import division  # no need to convert to float
from __future__ import print_function
from __future__ import unicode_literals
from future_builtins import *
endsnippet

snippet qtimports "from PyQt4.Qcore ..." b
import sys
import time
from PyQt4.QtCore import (QTime, QTimer, Qt)
from PyQt4.QtCore import pyqtSignal as Signal
from PyQt4.QtGui import (QApplication, QLabel, QDialog, QLineEdit, QTextBrowser, QVBoxLayout)
endsnippet



snippet "(qtapp|qtapplication)" "ifmain QTapplication" br
if __name__ == "__main__":
	app = QApplication(sys.argv)  # https://goo.gl/uNiCXp
	form = Form()  # where Form is a user-defined type derived from QForm
	form.show()
	app.exec_()
endsnippet


snippet "(q|qt)dialog" "class Form(QDialog)" br
class Form(QDialog):

		def __init__(self, parent=None):
				super(Form, self).__init__(parent)
				self.browser = QTextBrowser()
				self.lineedit = QLineEdit("Type an expression and press Enter")
				self.lineedit.selectAll()
				layout = QVBoxLayout()
				layout.addWidget(self.browser)
				layout.addWidget(self.lineedit)
				self.setLayout(layout)
				self.lineedit.setFocus()
				self.lineedit.returnPressed.connect(self.updateUi)
				self.setWindowTitle("Calculate")


		def updateUi(self):
				try:
						text = unicode(self.lineedit.text())
						self.browser.append("{0} = <b>{1}</b>".format(text,
																eval(text)))
				except:
						self.browser.append("<font color=red>{0} is invalid!</font>"
																.format(text))
endsnippet
